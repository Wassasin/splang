\documentclass[14pt]{amsart}

\usepackage[british]{babel}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{color}
\usepackage{listings}
\usepackage{xspace}
\usepackage{url}

\newcommand{\splang}{\textsc{Splang}\xspace}

\title{\splang}
\author{Wouter Geraedts (0814857) \and Joshua Moerman (3009048)}
\date{}

\begin{document}
\maketitle

\tableofcontents

\section{Implementation}
For our SPL-compiler, \splang, we choose \emph{Haskell} as our implementation language. First of all because this is a \emph{functional programming language}, which is really helpful when defining datastructures. Another nice things is the \emph{\texttt{do}-syntax} of haskell, which makes it very easy (at least to some extend) to propagate for example error messages. Of course this part would also be very easy in a imperitave language.

One feature we miss out in Haskell is for example \emph{generics} as in \emph{Clean}. Of course there are more minor irritations because of some differences between Clean and Haskell.

\section{Parser}
We made our own parsing combinator library. It has infinite lookahead, but when performance matters there are also 1-lookahead combinators. We choose to make our own one, because then we would have full control of error messages and sourecode information. It is implemented in a monadic way.

\subsection{Grammar}
In order to parse the language we had to change the grammar a bit. First of all we added priorities to the different operators, so that the multiplication binds stronger than addition.

Secondly, we generalized the grammar a bit, not only function calls can be an assignment, but also expressions.

We also noted that the given grammar was ambiguous, because of the \emph{dangling else}. We didn't have to change this, nor choose an convention. Our parser has infinite lookahead, so we parse all possibilities and conclude that it is ambiguous, and throw an error.

At last there is the problem of left-recursion in the given grammar. Our parser is left-descent, so we had to do left-factoring. We also had to think about associativity of non-associative operators.

The used grammar is attached in the appendix.

\section{Scoping}
We distinguish three different scopes (from big to small): \emph{global}, \emph{function argument} and \emph{local}. If two identifiers are being declared in the same scope, an error will be thrown, but compilation will continue (to possibly catch more errors). If a identifier is being declared, but it was already declared in a bigger scope, we allow this, but we will give the user a warning (because it is probably not what you want, and might introduce subtle bugs). This is called shadowing, one can still initialize this shadowing identifier with the previous one, as shown here:

\begin{lstlisting}
Int x = 5; // Global
Void foo(){
    Int x = x; // Warning: x shadows global x
               // x will be still initialized with the global x,
               // so: x == 5 is true
}
\end{lstlisting}

Globals can be defined in any order you want. This for example allows mutual recursion. This also holds for variable declarations, so one can declare a variable using variables which are defined later. But the compiler does not make a dependency graph, so using a variable which is not defined yet, will result in using uninitialized memory.

As far as scoping is concerned variables can be used as a function, and functions can be passed to other functions. However the type system does not accept this, because the annotated type in the source can never be a function type.

\subsection{Type variable scoping}
Type variables have similar scoping rules. If two typevariables are used in the same scope, they will be exactly the same type. In the following example \texttt{x} and \texttt{y} are of the same type, and therefore the second \texttt{print} will fail to typecheck. (We will later see another reason why this program is not allowed by the compiler).

\begin{lstlisting}
[t] x = [];
[t] y = []; // Same type as x

Void main(){
	print(1:x);    // x is of type [Int]
	print(True:y); // y is of type [Bool] => Type error
}
\end{lstlisting}

There is however an exception to this. We assume that if a function uses a type variable, then it is a polymorphic function. This means that type variables in function arguments are always new, in fact, this is the only way to create a new type variable with the same name. For example:

\begin{lstlisting}
t x = /* ... */

// The following 't' is independent of the above
[t] reverse([t] list){
	/* ... */
}
\end{lstlisting}

\section{Typing}

Our compiler mainly does typechecking, but some type inference is also needed. Type inference is hard to define in a imperitave language, as the variables one is infering, might be used differently later on (and mutual recursion is hard). This led to a system which does both type inference and type checking.

We first determine the annotated types of every global variable and function. Then in each expression and function body those annotations are used to infer the actual type at every place in the expression or function body, and with this information the annotated type is checked. We also make sure that \texttt{return} statements really return what they should, and if there is no \texttt{return} statement, the function should return \texttt{Void}.

We only allow \texttt{Void} to occur as a return type of a function. So a list or tuples of voids will give an error. One also cannot supply void as argument, even when the function is polymorphic. For example \texttt{print(print(5))} will not compile for this reason.

We do not allow the programmer to write this:

\begin{lstlisting}
t x = 5;
\end{lstlisting}

Because it is weird to annotate x with a more general type than it really is. This is a explicit decision we made, technically the compiler is able to infer that \texttt{t == Int}. For variables allowing this code might seem reasonable, but allowing this also for function is wrong, as can be seen in the following example:

\begin{lstlisting}
Bool y = f();

// This should not be allowed
t f(){ return 5; }
\end{lstlisting}

Type checking the assignment of the global variable \texttt{y} is ok, since \texttt{f} returns everything you want. So we should not allow the type annotation given to the function \texttt{f}. For consistency we also enforce this for variables. We might at some point in the future allow this flexibility for variables.

\subsection{Formal rules}
at funcalls, use type annotation
at fundecl, initialize to free type variables
when fundecl is done inferring, check result with type annotation (while checking, must exists a bijection between ftv's)

\newcommand{\T}{\mathcal{T}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\s}{\ast}
\newcommand{\sn}[1]{{\s_{#1}}}

% $\T(\Gamma, x, \sigma) = \U(\tau[\vec{\alpha} := \vec{\beta}], \sigma) \circ \ast$
	
$\begin{array}{rcl}
	\T_{\mbox{d}}(\Gamma, \mbox{Program}~\vec{d}) & = & \s_n \\
	\sn{n} & = & \T_{\mbox{d}}(\Gamma^{\sn{n-1}}, d_n) \circ \sn{n-1} \\
	& \vdots & \\
	\sn{2} & = & \T_{\mbox{d}}(\Gamma^{\sn{1}}, d_2) \circ \sn{1} \\
	\sn{1} & = & \T_{\mbox{d}}(\Gamma, d_1) \\
\end{array}$

$\begin{array}{rcl}
	\T_{\mbox{d}}(\Gamma, \mbox{VarDecl}~t~x~e) & = & \T(\Gamma, e, \tau) \\
	\forall \emptyset . \tau	& = & \Gamma(x) \\
\end{array}$

$\begin{array}{rcl}
	\T_{\mbox{d}}(\Gamma, \mbox{FunDecl}~t~x~\vec{\mbox{arg}}~\vec{\mbox{stmt}}) & = & \U(\theta^\sn{1}, \upsilon^\sn{1}) \circ \sn{1} \\
	\upsilon	& = & \vec{\alpha}^\sn{1} \rightarrow \beta^\sn{1} \\
	\sn{1}		& = & \sn{(2,n)} \\
	\sn{(2,n)}	& = & \T(\Gamma^\sn{(2,n-1)}, \mbox{stmt}_n, \beta^\sn{(2,n-1)}) \circ \sn{(2,n-1)} \\
	& \vdots & \\
	\sn{(2,2)}	& = & \T(\Gamma^\sn{(2,1)}, \mbox{stmt}_2, \beta^\sn{(2,1)}) \circ \sn{(2,2)} \\
	\sn{(2,1)}	& = & \T(\Gamma^\sn{3}, \mbox{stmt}_1, \beta^\sn{3}) \circ \sn{3} \\
	
	
\end{array}$



\section{Tests}
All tests are performed with the \texttt{--show-input --show-stages} flags, and all colors are stripped.
\subsection{Parsing}
\begin{itemize}
	\item[fail\_ambi] This program can be read ambiguously. Note that the compiler detects this, and prints out all possible interpretations. However this error is not fatal, and the compilation continues, and catches a typing error: the \texttt{if}-construct expects a \texttt{Bool}, but an \texttt{Int} was given.
\end{itemize}
\subsection{Binding}
\begin{itemize}
	\item[warn\_shadowing] This shows the warnings one get when redeclaring the same identifier in a more specific scope. Note that the functions \texttt{x} and \texttt{y} are both identity functions.
	\item[fail\_identifier\_errors] If one redeclares identifiers in the same scope, an non-fatal error will be given. Note that compilation continues and more errors are found. If an identifiers is undeclared, a suggestion is given by the compiler.
\end{itemize}
\subsection{Typing}
\begin{itemize}
	\item[fail\_arguments] Shows the error messages you get when you don't suply the right amount of arguments. Also note that the arguments that \emph{are} supplied, are also type checked.
	\item[fail\_void\_no\_return] Shows that we do not accept a returning function without return statement. Specifically, we see that the compiler infers that \texttt{foo} returns \texttt{Void}, instead of \texttt{Int}. Furthermore we see that we cannot use values of type \texttt{Void}.
\end{itemize}

\section{Reflection}
The work was more or less equally divided, as we seen on github:

\url{https://github.com/Wassasin/splang}

\end{document}
